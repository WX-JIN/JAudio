package com.soubw.jaudio;

import android.annotation.SuppressLint;
import android.media.MediaCodec;
import android.media.MediaExtractor;
import android.media.MediaFormat;

import java.io.File;
import java.io.IOException;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.nio.ShortBuffer;
import java.util.Arrays;


@SuppressLint("NewApi")
public class JAudioFile {

    // Progress listener interface.
    public interface OnJAudioFileListener {
        //返回加载文件或记录音频进度（0和1之间），如果手动要求停止阅读文件。立即返回false。这个
        //音乐文件对象是无效的，之后不能正常使用。
        boolean reportProgress(double fractionComplete);
    }

    /**
     * 自定义异常
     */
    public class InvalidInputException extends Exception {
        // Serial version ID generated by Eclipse.
        private static final long serialVersionUID = -2505698991597837165L;
        public InvalidInputException(String message) {
            super(message);
        }
    }

    private OnJAudioFileListener onJAudioFileListener;
    /**
     * 音频文件
     */
    private File file = null;

    // Member variables representing frame data
    private String fileType;
    private int fileSize;
    /**
     * kbps的平均比特率
     */
    private int AverageBitRate;
    /**
     * 取样频率
     */
    private int sampleRate;
    /**
     * 声道个数：单声道或双声道
     */
    private int soundChanelCount;
    /**
     * 音频文件中的声道样本总数
     */
    private int soundSampleCount;
    private ByteBuffer mDecodedBytes;  // 原始音频数据
    private ShortBuffer mDecodedSamples;  // shared buffer with mDecodedBytes.
    // mDecodedSamples has the following format:
    // {s1c1, s1c2, ..., s1cM, s2c1, ..., s2cM, ..., sNc1, ..., sNcM}
    // where sicj is the ith sample of the jth channel (a sample is a signed short)
    // M is the number of channels (e.g. 2 for stereo) and N is the number of samples per channel.

    /**
     *  音频文件总帧数（int数据类型）
     */
    private int frameCount;
    /**
     * 音频文件总帧数（float数据类型,为了处理，不能整除的情况下加一帧）
     */
    private float frameCountFloat;

    private int[] mFrameGains;



    /**
     * @return 每帧的样本数（值越大，之后处理波形就会越细）
     */
    public int getSamplesPerFrame() {
        return 1024/2;//1024/2
    }

    public int getSampleRate() {
        return sampleRate;
    }

    public int getSoundChanelCount() {
        return soundChanelCount;
    }

    public int getSoundSampleCount() {
        return soundSampleCount;
    }

    public int getFrameCount() {
        return frameCount;
    }

    public float getFrameCountFloat() {
        return frameCountFloat;
    }

    public int[] getFrameGains() {
        return mFrameGains;
    }

    public ShortBuffer getSamples() {
        if (mDecodedSamples != null) {
            return mDecodedSamples.asReadOnlyBuffer();
        } else {
            return null;
        }
    }

    private void setOnJAudioFileListener(OnJAudioFileListener l) {
        onJAudioFileListener = l;
    }


    // TODO(nfaralli): what is the real list of supported extensions? Is it device dependent?
    public static String[] getSupportedExtensions() {
        return new String[] {"mp3", "wav", "3gpp", "3gp", "amr", "aac", "m4a", "ogg"};
    }

    public static JAudioFile create(String fileName, OnJAudioFileListener onJAudioFileListener)
            throws IOException, InvalidInputException {
        File f = new File(fileName);
        if (!f.exists()) {
            throw new java.io.FileNotFoundException(fileName);
        }
        String name = f.getName().toLowerCase();
        String[] components = name.split("\\.");
        if (components.length < 2) {
            return null;
        }
        if (!Arrays.asList(getSupportedExtensions()).contains(components[components.length - 1])) {
            return null;
        }
        JAudioFile jAudioFile = new JAudioFile();
        jAudioFile.setOnJAudioFileListener(onJAudioFileListener);
        jAudioFile.ReadFile(f);
        return jAudioFile;
    }

    /**
     * @param file
     * @throws IOException
     * @throws InvalidInputException
     */
    private void ReadFile(File file) throws IOException, InvalidInputException {

        MediaExtractor extractor = new MediaExtractor();/** 用来读取音频文件 */
        MediaFormat format = null;
        this.file = file;
        /**
         * 获取文件类型（通过后缀去获取），获取文件长度
         */
        String[] components = this.file.getPath().split("\\.");
        fileType = components[components.length - 1];
        fileSize = (int) this.file.length();

        extractor.setDataSource(this.file.getPath());//根据路径获取源文件
        int numTracks = extractor.getTrackCount();
        int currentIndex;//正确第一个音频轨道下标
        for (currentIndex = 0; currentIndex<numTracks; currentIndex++) {//为了查找并选择文件中的第一个音频轨道
            format = extractor.getTrackFormat(currentIndex);//音频文件信息（其实一般是0就可以了）
            if (format.getString(MediaFormat.KEY_MIME).startsWith("audio/")) {// 检查是否为音频文件
                extractor.selectTrack(currentIndex);
                break;
            }
        }
        if (numTracks  == currentIndex) {
            throw new InvalidInputException("No audio track found in " + this.file);
        }
        soundChanelCount = format.getInteger(MediaFormat.KEY_CHANNEL_COUNT);// 声道个数：单声道或双声道
        sampleRate = format.getInteger(MediaFormat.KEY_SAMPLE_RATE);//取样频率
        // 预测每通道的样本数
        int expectedNumSamples = (int)((format.getLong(MediaFormat.KEY_DURATION) / 1000000.f) * sampleRate + 0.5f);

        /** 解码 */
        MediaCodec codec = MediaCodec.createDecoderByType(format.getString(MediaFormat.KEY_MIME));//实例化一个指定类型的解码器,提供数据输出
        codec.configure(format, null, null, 0);
        codec.start();

        int decodedSamplesSize = 0; //包含解码样本的输出缓冲区的大小
        byte[] decodedSamples = null;
        ByteBuffer[] inputBuffers = codec.getInputBuffers();// 用来存放目标文件的数据
        ByteBuffer[] outputBuffers = codec.getOutputBuffers(); // 解码后的数据

        // ==========开始解码=============
        int sample_size;
        MediaCodec.BufferInfo info = new MediaCodec.BufferInfo();
        long presentation_time;
        int tot_size_read = 0;
        boolean done_reading = false;

        //设置解码样本缓冲区的大小为1MB（~ 44.1khz的立体流6sec）。对于更长的流，缓冲区大小将增加，计算一个粗糙的
        //需要存储所有的样本以调整缓冲区的总大小的估计
        mDecodedBytes = ByteBuffer.allocate(1<<20);
        Boolean firstSampleData = true;
        while (true) {
            // read data from file and feed it to the decoder input buffers.
            int inputBufferIndex = codec.dequeueInputBuffer(100);
            if (!done_reading && inputBufferIndex >= 0) {
                sample_size = extractor.readSampleData(inputBuffers[inputBufferIndex], 0);
                if (firstSampleData && format.getString(MediaFormat.KEY_MIME).equals("audio/mp4a-latm")
                        && sample_size == 2) {
                    // For some reasons on some devices (e.g. the Samsung S3) you should not
                    // provide the first two bytes of an AAC stream, otherwise the MediaCodec will
                    // crash. These two bytes do not contain music data but basic info on the
                    // stream (e.g. channel configuration and sampling frequency), and skipping them
                    // seems OK with other devices (MediaCodec has already been configured and
                    // already knows these parameters).
                    extractor.advance();
                    tot_size_read += sample_size;
                } else if (sample_size < 0) {
                    // All samples have been read.
                    codec.queueInputBuffer(
                            inputBufferIndex, 0, 0, -1, MediaCodec.BUFFER_FLAG_END_OF_STREAM);
                    done_reading = true;
                } else {
                    presentation_time = extractor.getSampleTime();
                    codec.queueInputBuffer(inputBufferIndex, 0, sample_size, presentation_time, 0);
                    extractor.advance();
                    tot_size_read += sample_size;
                    if (onJAudioFileListener != null) {
                        if (!onJAudioFileListener.reportProgress((float)(tot_size_read) / fileSize)) {
                            extractor.release();
                            extractor = null;
                            codec.stop();
                            codec.release();
                            codec = null;
                            return;
                        }
                    }
                }
                firstSampleData = false;
            }

            // Get decoded stream from the decoder output buffers.
            int outputBufferIndex = codec.dequeueOutputBuffer(info, 100);
            if (outputBufferIndex >= 0 && info.size > 0) {
                if (decodedSamplesSize < info.size) {
                    decodedSamplesSize = info.size;
                    decodedSamples = new byte[decodedSamplesSize];
                }
                outputBuffers[outputBufferIndex].get(decodedSamples, 0, info.size);
                outputBuffers[outputBufferIndex].clear();
                // Check if buffer is big enough. Resize it if it's too small.
                if (mDecodedBytes.remaining() < info.size) {
                    // Getting a rough estimate of the total size, allocate 20% more, and
                    // make sure to allocate at least 5MB more than the initial size.
                    int position = mDecodedBytes.position();
                    int newSize = (int)((position * (1.0 * fileSize / tot_size_read)) * 1.2);
                    if (newSize - position < info.size + 5 * (1<<20)) {
                        newSize = position + info.size + 5 * (1<<20);
                    }
                    ByteBuffer newDecodedBytes = null;
                    // Try to allocate memory. If we are OOM, try to run the garbage collector.
                    int retry = 10;
                    while(retry > 0) {
                        try {
                            newDecodedBytes = ByteBuffer.allocate(newSize);
                            break;
                        } catch (OutOfMemoryError oome) {
                            // setting android:largeHeap="true" in <application> seem to help not
                            // reaching this section.
                            retry--;
                        }
                    }
                    if (retry == 0) {
                        // Failed to allocate memory... Stop reading more data and finalize the
                        // instance with the data decoded so far.
                        break;
                    }
                    //ByteBuffer newDecodedBytes = ByteBuffer.allocate(newSize);
                    mDecodedBytes.rewind();
                    newDecodedBytes.put(mDecodedBytes);
                    mDecodedBytes = newDecodedBytes;
                    mDecodedBytes.position(position);
                }
                mDecodedBytes.put(decodedSamples, 0, info.size);
                codec.releaseOutputBuffer(outputBufferIndex, false);
            } else if (outputBufferIndex == MediaCodec.INFO_OUTPUT_BUFFERS_CHANGED) {
                outputBuffers = codec.getOutputBuffers();
            } else if (outputBufferIndex == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED) {
                // Subsequent data will conform to new format.
                // We could check that codec.getOutputFormat(), which is the new output format,
                // is what we expect.
            }
            if ((info.flags & MediaCodec.BUFFER_FLAG_END_OF_STREAM) != 0
                    || (mDecodedBytes.position() / (2 * soundChanelCount)) >= expectedNumSamples) {
                // We got all the decoded data from the decoder. Stop here.
                // Theoretically dequeueOutputBuffer(info, ...) should have set info.flags to
                // MediaCodec.BUFFER_FLAG_END_OF_STREAM. However some phones (e.g. Samsung S3)
                // won't do that for some files (e.g. with mono AAC files), in which case subsequent
                // calls to dequeueOutputBuffer may result in the application crashing, without
                // even an exception being thrown... Hence the second check.
                // (for mono AAC files, the S3 will actually double each sample, as if the stream
                // was stereo. The resulting stream is half what it's supposed to be and with a much
                // lower pitch.)
                break;
            }
        }
        soundSampleCount = mDecodedBytes.position() / (soundChanelCount * 2);  // One sample = 2 bytes.
        mDecodedBytes.rewind();
        mDecodedBytes.order(ByteOrder.LITTLE_ENDIAN);
        mDecodedSamples = mDecodedBytes.asShortBuffer();
        AverageBitRate = (int)((fileSize * 8) * ((float) sampleRate / soundSampleCount) / 1000);

        extractor.release();
        extractor = null;
        codec.stop();
        codec.release();
        codec = null;

        frameCount = soundSampleCount / getSamplesPerFrame();
        frameCountFloat = (float) soundSampleCount / getSamplesPerFrame();
        if (soundSampleCount % getSamplesPerFrame() != 0){//不能整除的情况下加一帧
            frameCount++;
        }
        mFrameGains = new int[frameCount];
        int i;
        int j;
        int gain, value;
        for (i=0; i< frameCount; i++){
            gain = -1;
            for(j=0; j<getSamplesPerFrame(); j++) {
                value = 0;
                for (int k = 0; k< soundChanelCount; k++) {
                    if (mDecodedSamples.remaining() > 0) {
                        value += Math.abs(mDecodedSamples.get());
                    }
                }
                value /= soundChanelCount;
                if (gain < value) {
                    gain = value;
                }
            }
            mFrameGains[i] = (int)Math.sqrt(gain);  // here gain = sqrt(max value of 1st channel)...
        }
        mDecodedSamples.rewind();
        // DumpSamples();  // Uncomment this line to dump the samples in a TSV file.
    }
}
